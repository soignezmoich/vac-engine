defmodule VacEngine.Processor do
  @moduledoc """
  ## Processor Module
  The Processor module is responsible for generating and executing functions
  to compute API output from API input.

  ### Structure
  The entities involved in this system are:

  #### processors
  Processors are in memory functions that compute the API output
  from the API input.

  #### blueprints
  DB storable entities that describe the behaviour of a processor.
  Blueprints contain variables and deductions (in addition to basic properties
  such as name or creation date).

  #### variables
  Variables describe the values the processor can receive (input),
  return (output) or compute as intermediary values.
  They are attached to a type, a position in the input or output
  and some other properties like optional/required.

  #### deductions
  Deductions are descriptions of how intermediary and output variables
  should be computed. They are built as tables whose columns correspond
  to the involved variables (assigned one or ones playing role in conditions)
  and the rows to subsidiary conditions/assignement branches (if the conditions
  of the first branch are not met, the second branch is tested, and so on).

  #### branches
  A (possibly empty) set of conditions on certain variables linked with
  an assignation to other (or same) variables.

  #### condition
  An expression describing when the condition is met based on
  it's column's variable.

  #### assignment
  An expression describing the value the column's variable should take
  in case the branch conditions are met.

  #### expression
  Either a constant, a variable or a function involving other expressions
  that can be computed based on the current variables state. Condition
  expressions return nullable booleans, assignment expression return a nullable
  value of the type of the column's variable.

  ### Mode of operation
  Processors can take several forms:
  1. as elixir code blueprint description (used as source only)
  2. as json code blueprint description (used to import/export blueprint
    from an instance of the application to another)
  3. in base as blueprint
  4. as serialized blueprint
  5. as compiled processor function (in memory)

  The form 1 is used exclusively to describe the blueprint using
  a text editor.
  The form 2 is used to migrate or store a blueprint.
  The form 3 is the one used to store the blueprint in the app. It is also
  The form generated by the UI form editor (TODO not released yet).
  The form 4 is a transitional state that allow compilation by elixir. (TODO ?)
  The form 5 is the one used when API calls are made. Not having
  to make db calls during the processing greatly increases the response time.

  """
  alias VacEngine.Processor
  alias VacEngine.Processor.Blueprint
  alias VacEngine.Processor.Blueprints
  alias VacEngine.Processor.Compiler
  alias VacEngine.Processor.State
  alias VacEngine.Processor.Variables
  alias VacEngine.Processor.Info

  @doc """
  Create a blueprint with the given attributes
  TODO describe attributes
  """
  defdelegate create_blueprint(workspace, attrs), to: Blueprints

  @doc """
  Cast attributes into a changeset
  TODO difference with update_blueprint
  Only root attributes are supported (no variables or deductions)
  """
  defdelegate change_blueprint(blueprint, attrs \\ %{}), to: Blueprints

  @doc """
  Update a blueprint with attributes
  """
  defdelegate update_blueprint(blueprint, attrs), to: Blueprints

  @doc """
  Get a blueprint with id, raise if not found.
  """
  defdelegate get_blueprint!(blueprint_id), to: Blueprints

  @doc """
  Convert to map for serialization
  """
  defdelegate serialize_blueprint(blueprint), to: Blueprints

  @doc """
  Load a blueprint from a file.

  Used for file upload as phoenix write into temp file
  """
  defdelegate update_blueprint_from_file(blueprint, path), to: Blueprints

  @doc """
  Load variables and index them
  """
  defdelegate load_variables(blueprint), to: Blueprints

  @doc """
  Load deductions and arrange them, load_variables MUST be called first
  """
  defdelegate load_deductions(blueprint), to: Blueprints

  @doc """
  Create variable with attributes
  """
  defdelegate create_variable(parent, attrs), to: Variables

  @doc """
  Update variable with attributes
  """
  defdelegate update_variable(var, attrs), to: Variables

  @doc """
  Delete variable (will error if variable is in use)
  """
  defdelegate delete_variable(var), to: Variables

  @doc """
  Move variable to new parent
  """
  defdelegate move_variable(var, new_parent), to: Variables

  defstruct blueprint: nil, compiled_ast: nil, state: nil, info: nil

  @doc """
  Compile blueprint into processor
  """
  def compile_blueprint(%Blueprint{} = blueprint) do
    with {:ok, compiled_ast} <- Compiler.compile_blueprint(blueprint),
         {:ok, info} <- Info.describe(blueprint),
         {:ok, state} <- State.new(blueprint.variables) do
      {:ok,
       %Processor{
         compiled_ast: compiled_ast,
         state: state,
         blueprint: blueprint,
         info: info
       }}
    else
      {:error, err} ->
        {:error, "cannot compile blueprint: #{err}"}
    end
  end

  @doc """
  Run processor with given input
  """
  def run(%Processor{} = processor, input) do
    with {:ok, state} <- State.map_input(processor.state, input),
         {:ok, state} <- Compiler.eval_ast(processor.compiled_ast, state),
         {:ok, state} <- State.finalize_output(state) do
      {:ok, state}
    else
      {:error, msg} ->
        {:error, msg}
    end
  end
end
